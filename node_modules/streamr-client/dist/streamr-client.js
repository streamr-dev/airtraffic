(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("streamr-client", [], factory);
	else if(typeof exports === 'object')
		exports["StreamrClient"] = factory();
	else
		root["StreamrClient"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 25);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/classCallCheck");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/regenerator");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/asyncToGenerator");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/createClass");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("debug");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/get-prototype-of");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/possibleConstructorReturn");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/inherits");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/assign");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/keys");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("streamr-client-protocol");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/json/stringify");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("eventemitter3");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.authFetch = undefined;

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends2 = __webpack_require__(16);

var _extends3 = _interopRequireDefault(_extends2);

var _asyncToGenerator2 = __webpack_require__(2);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _nodeFetch = __webpack_require__(30);

var _nodeFetch2 = _interopRequireDefault(_nodeFetch);

var _debug = __webpack_require__(4);

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)('StreamrClient:utils');

var authFetch = exports.authFetch = function () {
    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(url, session) {
        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var requireNewToken = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var authHeader, token, req, res, text;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        debug('authFetch: ', url, opts);
                        authHeader = {};

                        if (!(session && !session.options.unauthenticated)) {
                            _context.next = 7;
                            break;
                        }

                        _context.next = 5;
                        return session.getSessionToken(requireNewToken);

                    case 5:
                        token = _context.sent;

                        authHeader.Authorization = 'Bearer ' + token;

                    case 7:
                        req = (0, _extends3.default)({}, opts, {
                            headers: (0, _extends3.default)({}, authHeader, opts.headers || {})
                        });
                        _context.next = 10;
                        return (0, _nodeFetch2.default)(url, req);

                    case 10:
                        res = _context.sent;
                        _context.next = 13;
                        return res.text();

                    case 13:
                        text = _context.sent;

                        if (!(res.ok && text.length)) {
                            _context.next = 24;
                            break;
                        }

                        _context.prev = 15;
                        return _context.abrupt('return', JSON.parse(text));

                    case 19:
                        _context.prev = 19;
                        _context.t0 = _context['catch'](15);
                        throw new Error('Failed to parse JSON response: ' + text);

                    case 22:
                        _context.next = 33;
                        break;

                    case 24:
                        if (!res.ok) {
                            _context.next = 28;
                            break;
                        }

                        return _context.abrupt('return', {});

                    case 28:
                        if (!((res.status === 400 || res.status === 401) && !requireNewToken)) {
                            _context.next = 32;
                            break;
                        }

                        return _context.abrupt('return', authFetch(url, session, opts, true));

                    case 32:
                        throw new Error('Request to ' + url + ' returned with error code ' + res.status + ': ' + text);

                    case 33:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, undefined, [[15, 19]]);
    }));

    return function authFetch(_x, _x2) {
        return _ref.apply(this, arguments);
    };
}();

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/promise");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _keys = __webpack_require__(9);

var _keys2 = _interopRequireDefault(_keys);

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = __webpack_require__(11);

var _stringify2 = _interopRequireDefault(_stringify);

var _asyncToGenerator2 = __webpack_require__(2);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(3);

var _createClass3 = _interopRequireDefault(_createClass2);

var _utils = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Stream = function () {
    function Stream(client, props) {
        (0, _classCallCheck3.default)(this, Stream);

        this._client = client;
        (0, _assign2.default)(this, props);
    }

    (0, _createClass3.default)(Stream, [{
        key: 'update',
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                var json;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return (0, _utils.authFetch)(this._client.options.restUrl + '/streams/' + this.id, this._client.session, {
                                    method: 'PUT',
                                    body: (0, _stringify2.default)(this.toObject())
                                });

                            case 2:
                                json = _context.sent;
                                return _context.abrupt('return', json ? new Stream(this._client, json) : undefined);

                            case 4:
                            case 'end':
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function update() {
                return _ref.apply(this, arguments);
            }

            return update;
        }()
    }, {
        key: 'toObject',
        value: function toObject() {
            var _this = this;

            var result = {};
            (0, _keys2.default)(this).forEach(function (key) {
                if (!key.startsWith('_')) {
                    result[key] = _this[key];
                }
            });
            return result;
        }
    }, {
        key: 'delete',
        value: function _delete() {
            return (0, _utils.authFetch)(this._client.options.restUrl + '/streams/' + this.id, this._client.session, {
                method: 'DELETE'
            });
        }
    }, {
        key: 'getPermissions',
        value: function getPermissions() {
            return (0, _utils.authFetch)(this._client.options.restUrl + '/streams/' + this.id + '/permissions', this._client.session);
        }
    }, {
        key: 'detectFields',
        value: function detectFields() {
            return (0, _utils.authFetch)(this._client.options.restUrl + '/streams/' + this.id + '/detectFields', this._client.session);
        }
    }, {
        key: 'publish',
        value: function publish(data) {
            var timestamp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();

            return this._client.publish(this.id, data, timestamp);
        }
    }]);
    return Stream;
}();

exports.default = Stream;
module.exports = exports['default'];

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/extends");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("web3");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("web3-fake-provider");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _set = __webpack_require__(20);

var _set2 = _interopRequireDefault(_set);

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(2);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(3);

var _createClass3 = _interopRequireDefault(_createClass2);

var _streamrClientProtocol = __webpack_require__(10);

var _web = __webpack_require__(17);

var _web2 = _interopRequireDefault(_web);

var _web3FakeProvider = __webpack_require__(18);

var _web3FakeProvider2 = _interopRequireDefault(_web3FakeProvider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = __webpack_require__(4)('StreamrClient::Signer');

var web3 = new _web2.default(new _web3FakeProvider2.default());

var SIGNATURE_TYPE_ETH = 1;

var Signer = function () {
    function Signer() {
        var _this = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck3.default)(this, Signer);

        this.options = options;
        if (this.options.privateKey) {
            var account = web3.eth.accounts.privateKeyToAccount(this.options.privateKey);
            this.address = account.address.toLowerCase();
            this.sign = function (d) {
                return account.sign(d).signature;
            };
        } else if (this.options.provider) {
            this.sign = function () {
                var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(d) {
                    var w3, accounts, address;
                    return _regenerator2.default.wrap(function _callee$(_context) {
                        while (1) {
                            switch (_context.prev = _context.next) {
                                case 0:
                                    w3 = new _web2.default(_this.options.provider);
                                    _context.next = 3;
                                    return w3.eth.getAccounts();

                                case 3:
                                    accounts = _context.sent;
                                    address = accounts[0];

                                    if (address) {
                                        _context.next = 7;
                                        break;
                                    }

                                    throw new Error('Cannot access account from provider');

                                case 7:
                                    _this.address = address;
                                    return _context.abrupt('return', w3.eth.personal.sign(d, _this.address));

                                case 9:
                                case 'end':
                                    return _context.stop();
                            }
                        }
                    }, _callee, _this);
                }));

                return function (_x2) {
                    return _ref.apply(this, arguments);
                };
            }();
        } else {
            throw new Error('Need either "privateKey" or "provider".');
        }
    }

    (0, _createClass3.default)(Signer, [{
        key: 'signData',
        value: function () {
            var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(data) {
                var signatureType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SIGNATURE_TYPE_ETH;
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                if (!(signatureType === SIGNATURE_TYPE_ETH)) {
                                    _context2.next = 2;
                                    break;
                                }

                                return _context2.abrupt('return', this.sign(data));

                            case 2:
                                throw new Error('Unrecognized signature type: ' + signatureType);

                            case 3:
                            case 'end':
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function signData(_x3) {
                return _ref2.apply(this, arguments);
            }

            return signData;
        }()
    }, {
        key: 'getSignedPublishRequest',
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(publishRequest) {
                var signatureType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SIGNATURE_TYPE_ETH;
                var ts, payload, signature;
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                ts = publishRequest.getTimestampAsNumber();

                                if (ts) {
                                    _context3.next = 3;
                                    break;
                                }

                                throw new Error('Timestamp is required as part of the data to sign.');

                            case 3:
                                payload = Signer.getPayloadToSign(publishRequest.streamId, ts, this.address, publishRequest.getSerializedContent(), signatureType);
                                _context3.next = 6;
                                return this.signData(payload, signatureType);

                            case 6:
                                signature = _context3.sent;
                                return _context3.abrupt('return', new _streamrClientProtocol.PublishRequest(publishRequest.streamId, publishRequest.apiKey, publishRequest.sessionToken, publishRequest.content, publishRequest.timestamp, publishRequest.partitionKey, this.address, signatureType, signature));

                            case 8:
                            case 'end':
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function getSignedPublishRequest(_x5) {
                return _ref3.apply(this, arguments);
            }

            return getSignedPublishRequest;
        }()
    }], [{
        key: 'getPayloadToSign',
        value: function getPayloadToSign(streamId, timestamp, publisherId, content) {
            var signatureType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : SIGNATURE_TYPE_ETH;

            if (signatureType === SIGNATURE_TYPE_ETH) {
                return '' + streamId + timestamp + publisherId.toLowerCase() + content;
            }
            throw new Error('Unrecognized signature type: ' + signatureType);
        }
    }, {
        key: 'verifySignature',
        value: function verifySignature(data, signature, address) {
            var signatureType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : SIGNATURE_TYPE_ETH;

            if (signatureType === SIGNATURE_TYPE_ETH) {
                return web3.eth.accounts.recover(data, signature).toLowerCase() === address.toLowerCase();
            }
            throw new Error('Unrecognized signature type: ' + signatureType);
        }
    }, {
        key: 'verifyStreamMessage',
        value: function verifyStreamMessage(msg) {
            var trustedPublishers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _set2.default();

            var payload = this.getPayloadToSign(msg.streamId, msg.timestamp, msg.publisherAddress, msg.getSerializedContent());
            var result = this.verifySignature(payload, msg.signature, msg.publisherAddress, msg.signatureType) && trustedPublishers.has(msg.publisherAddress.toLowerCase());
            debug('verifyStreamMessage: pass: %o, message: %o', result, msg);
            return result;
        }
    }, {
        key: 'createSigner',
        value: function createSigner(options, publishWithSignature) {
            if (publishWithSignature === 'never') {
                return undefined;
            } else if (publishWithSignature === 'auto' && !options.privateKey && !options.provider) {
                return undefined;
            } else if (publishWithSignature === 'auto' || publishWithSignature === 'always') {
                return new Signer(options);
            }
            throw new Error('Unknown parameter value: ' + publishWithSignature);
        }
    }]);
    return Signer;
}();

exports.default = Signer;
module.exports = exports['default'];

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/set");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/create");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/set-prototype-of");

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/array/from");

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/reflect/construct");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _StreamrClient = __webpack_require__(26);

var _StreamrClient2 = _interopRequireDefault(_StreamrClient);

var _AllEndpoints = __webpack_require__(38);

var AllEndpoints = _interopRequireWildcard(_AllEndpoints);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Mixin the rest endpoints to the StreamrClient
(0, _assign2.default)(_StreamrClient2.default.prototype, AllEndpoints);

exports.default = _StreamrClient2.default;
module.exports = exports['default'];

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _typeof2 = __webpack_require__(27);

var _typeof3 = _interopRequireDefault(_typeof2);

var _toConsumableArray2 = __webpack_require__(28);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _keys = __webpack_require__(9);

var _keys2 = _interopRequireDefault(_keys);

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(2);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _getPrototypeOf = __webpack_require__(5);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(3);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(6);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(7);

var _inherits3 = _interopRequireDefault(_inherits2);

var _eventemitter = __webpack_require__(12);

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _debug = __webpack_require__(4);

var _debug2 = _interopRequireDefault(_debug);

var _streamrClientProtocol = __webpack_require__(10);

var _Subscription = __webpack_require__(29);

var _Subscription2 = _interopRequireDefault(_Subscription);

var _Stream = __webpack_require__(15);

var _Stream2 = _interopRequireDefault(_Stream);

var _Connection = __webpack_require__(31);

var _Connection2 = _interopRequireDefault(_Connection);

var _Session = __webpack_require__(33);

var _Session2 = _interopRequireDefault(_Session);

var _Signer = __webpack_require__(19);

var _Signer2 = _interopRequireDefault(_Signer);

var _FailedToPublishError = __webpack_require__(34);

var _FailedToPublishError2 = _interopRequireDefault(_FailedToPublishError);

var _InvalidSignatureError = __webpack_require__(35);

var _InvalidSignatureError2 = _interopRequireDefault(_InvalidSignatureError);

var _SubscribedStream = __webpack_require__(36);

var _SubscribedStream2 = _interopRequireDefault(_SubscribedStream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)('StreamrClient');

var StreamrClient = function (_EventEmitter) {
    (0, _inherits3.default)(StreamrClient, _EventEmitter);

    function StreamrClient(options, connection) {
        var _this2 = this;

        (0, _classCallCheck3.default)(this, StreamrClient);

        // Default options
        var _this = (0, _possibleConstructorReturn3.default)(this, (StreamrClient.__proto__ || (0, _getPrototypeOf2.default)(StreamrClient)).call(this));

        _this.options = {
            // The server to connect to
            url: 'wss://www.streamr.com/api/v1/ws?controlLayerVersion=0&messageLayerVersion=29',
            restUrl: 'https://www.streamr.com/api/v1',
            // Automatically connect on first subscribe
            autoConnect: true,
            // Automatically disconnect on last unsubscribe
            autoDisconnect: true,
            auth: {},
            publishWithSignature: 'auto',
            verifySignatures: 'auto'
        };
        _this.subscribedStreams = {};
        _this.publishQueue = [];

        (0, _assign2.default)(_this.options, options || {});

        // Backwards compatibility for option 'authKey' => 'apiKey'
        if (_this.options.authKey && !_this.options.apiKey) {
            _this.options.apiKey = _this.options.authKey;
        }
        if (_this.options.apiKey) {
            _this.options.auth.apiKey = _this.options.apiKey;
        }

        if (_this.options.auth.privateKey && !_this.options.auth.privateKey.startsWith('0x')) {
            _this.options.auth.privateKey = '0x' + _this.options.auth.privateKey;
        }

        _this.session = new _Session2.default(_this, _this.options.auth);
        _this.signer = _Signer2.default.createSigner(_this.options.auth, _this.options.publishWithSignature);
        // Event handling on connection object
        _this.connection = connection || new _Connection2.default(_this.options);

        // Broadcast messages to all subs listening on stream
        _this.connection.on('BroadcastMessage', function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(msg) {
                var stream, valid, error;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                stream = _this.subscribedStreams[msg.payload.streamId];

                                if (!stream) {
                                    _context.next = 8;
                                    break;
                                }

                                _context.next = 4;
                                return stream.verifyStreamMessage(msg.payload);

                            case 4:
                                valid = _context.sent;

                                if (valid) {
                                    // Notify the Subscriptions for this stream. If this is not the message each individual Subscription
                                    // is expecting, they will either ignore it or request resend via gap event.
                                    stream.getSubscriptions().forEach(function (sub) {
                                        return sub.handleMessage(msg.payload, false);
                                    });
                                } else {
                                    error = new _InvalidSignatureError2.default(msg.payload);

                                    stream.getSubscriptions().forEach(function (sub) {
                                        return sub.handleError(error);
                                    });
                                }
                                _context.next = 9;
                                break;

                            case 8:
                                debug('WARN: message received for stream with no subscriptions: %s', msg.payload.streamId);

                            case 9:
                            case 'end':
                                return _context.stop();
                        }
                    }
                }, _callee, _this2);
            }));

            return function (_x) {
                return _ref.apply(this, arguments);
            };
        }());

        // Unicast messages to a specific subscription only
        _this.connection.on('UnicastMessage', function () {
            var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(msg) {
                var stream, sub, valid;
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                stream = _this.subscribedStreams[msg.payload.streamId];

                                if (!stream) {
                                    _context2.next = 13;
                                    break;
                                }

                                sub = stream.getSubscription(msg.subId);

                                if (!sub) {
                                    _context2.next = 10;
                                    break;
                                }

                                _context2.next = 6;
                                return stream.verifyStreamMessage(msg.payload);

                            case 6:
                                valid = _context2.sent;

                                if (valid) {
                                    sub.handleMessage(msg.payload, true);
                                } else {
                                    sub.handleError(new _InvalidSignatureError2.default(msg.payload));
                                }
                                _context2.next = 11;
                                break;

                            case 10:
                                debug('WARN: subscription not found for stream: %s, sub: %s', msg.payload.streamId, msg.subId);

                            case 11:
                                _context2.next = 14;
                                break;

                            case 13:
                                debug('WARN: message received for stream with no subscriptions: %s', msg.payload.streamId);

                            case 14:
                            case 'end':
                                return _context2.stop();
                        }
                    }
                }, _callee2, _this2);
            }));

            return function (_x2) {
                return _ref2.apply(this, arguments);
            };
        }());

        _this.connection.on('SubscribeResponse', function (response) {
            var stream = _this.subscribedStreams[response.payload.streamId];
            if (stream) {
                stream.setSubscribing(false);
                stream.getSubscriptions().filter(function (sub) {
                    return !sub.resending;
                }).forEach(function (sub) {
                    return sub.setState(_Subscription2.default.State.subscribed);
                });
            }
            debug('Client subscribed: %o', response.payload);
        });

        _this.connection.on('UnsubscribeResponse', function (response) {
            debug('Client unsubscribed: %o', response.payload);
            var stream = _this.subscribedStreams[response.payload.streamId];
            if (stream) {
                stream.getSubscriptions().forEach(function (sub) {
                    _this._removeSubscription(sub);
                    sub.setState(_Subscription2.default.State.unsubscribed);
                });
            }

            _this._checkAutoDisconnect();
        });

        // Route resending state messages to corresponding Subscriptions
        _this.connection.on('ResendResponseResending', function (response) {
            var stream = _this.subscribedStreams[response.payload.streamId];
            if (stream && stream.getSubscription(response.payload.subId)) {
                stream.getSubscription(response.payload.subId).emit('resending', response.payload);
            } else {
                debug('resent: Subscription %d is gone already', response.payload.subId);
            }
        });

        _this.connection.on('ResendResponseNoResend', function (response) {
            var stream = _this.subscribedStreams[response.payload.streamId];
            if (stream && stream.getSubscription(response.payload.subId)) {
                stream.getSubscription(response.payload.subId).emit('no_resend', response.payload);
            } else {
                debug('resent: Subscription %d is gone already', response.payload.subId);
            }
        });

        _this.connection.on('ResendResponseResent', function (response) {
            var stream = _this.subscribedStreams[response.payload.streamId];
            if (stream && stream.getSubscription(response.payload.subId)) {
                stream.getSubscription(response.payload.subId).emit('resent', response.payload);
            } else {
                debug('resent: Subscription %d is gone already', response.payload.subId);
            }
        });

        // On connect/reconnect, send pending subscription requests
        _this.connection.on('connected', function () {
            debug('Connected!');
            _this.emit('connected');

            // Check pending subscriptions
            (0, _keys2.default)(_this.subscribedStreams).forEach(function (streamId) {
                _this.subscribedStreams[streamId].getSubscriptions().forEach(function (sub) {
                    if (sub.getState() !== _Subscription2.default.State.subscribed) {
                        _this._resendAndSubscribe(sub);
                    }
                });
            });

            // Check pending publish requests
            var publishQueueCopy = _this.publishQueue.slice(0);
            _this.publishQueue = [];
            publishQueueCopy.forEach(function (args) {
                _this.publish.apply(_this, (0, _toConsumableArray3.default)(args));
            });
        });

        _this.connection.on('disconnected', function () {
            debug('Disconnected.');
            _this.emit('disconnected');

            (0, _keys2.default)(_this.subscribedStreams).forEach(function (streamId) {
                var stream = _this.subscribedStreams[streamId];
                stream.setSubscribing(false);
                stream.getSubscriptions().forEach(function (sub) {
                    sub.setState(_Subscription2.default.State.unsubscribed);
                });
            });
        });

        _this.connection.on('ErrorResponse', function (err) {
            var errorObject = new Error(err.payload.error);
            _this.emit('error', errorObject);
            console.error(errorObject.message);
        });

        _this.connection.on('error', function (err) {
            // If there is an error parsing a json message in a stream, fire error events on the relevant subs
            if (err instanceof _streamrClientProtocol.Errors.InvalidJsonError) {
                var stream = _this.subscribedStreams[err.streamId];
                if (stream) {
                    stream.getSubscriptions().forEach(function (sub) {
                        return sub.handleError(err);
                    });
                } else {
                    debug('WARN: InvalidJsonError received for stream with no subscriptions: %s', err.streamId);
                }
            } else {
                var errorObject = err instanceof Error ? err : new Error(err);
                _this.emit('error', errorObject);
                console.error(errorObject.message);
            }
        });
        return _this;
    }

    (0, _createClass3.default)(StreamrClient, [{
        key: '_addSubscription',
        value: function _addSubscription(sub) {
            if (!this.subscribedStreams[sub.streamId]) {
                this.subscribedStreams[sub.streamId] = new _SubscribedStream2.default(this, sub.streamId);
            }
            this.subscribedStreams[sub.streamId].addSubscription(sub);
        }
    }, {
        key: '_removeSubscription',
        value: function _removeSubscription(sub) {
            var stream = this.subscribedStreams[sub.streamId];
            if (stream) {
                stream.removeSubscription(sub);
                if (stream.getSubscriptions().length === 0) {
                    delete this.subscribedStreams[sub.streamId];
                }
            }
        }
    }, {
        key: 'getSubscriptions',
        value: function getSubscriptions(streamId) {
            var stream = this.subscribedStreams[streamId];
            return stream ? stream.getSubscriptions() : [];
        }
    }, {
        key: 'publish',
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(streamObjectOrId, data) {
                var timestamp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Date.now();
                var apiKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.options.auth.apiKey;
                var sessionToken, streamId;
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                _context3.next = 2;
                                return this.session.getSessionToken();

                            case 2:
                                sessionToken = _context3.sent;

                                // Validate streamObjectOrId
                                streamId = void 0;

                                if (!(streamObjectOrId instanceof _Stream2.default)) {
                                    _context3.next = 8;
                                    break;
                                }

                                streamId = streamObjectOrId.id;
                                _context3.next = 13;
                                break;

                            case 8:
                                if (!(typeof streamObjectOrId === 'string')) {
                                    _context3.next = 12;
                                    break;
                                }

                                streamId = streamObjectOrId;
                                _context3.next = 13;
                                break;

                            case 12:
                                throw new Error('First argument must be a Stream object or the stream id! Was: ' + streamObjectOrId);

                            case 13:
                                if (!((typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data)) !== 'object')) {
                                    _context3.next = 15;
                                    break;
                                }

                                throw new Error('Message data must be an object! Was: ' + data);

                            case 15:
                                if (!this.isConnected()) {
                                    _context3.next = 19;
                                    break;
                                }

                                this._requestPublish(streamId, data, timestamp, apiKey, sessionToken);
                                _context3.next = 25;
                                break;

                            case 19:
                                if (!this.options.autoConnect) {
                                    _context3.next = 24;
                                    break;
                                }

                                this.publishQueue.push([streamId, data, timestamp, apiKey]);
                                this.connect().catch(function () {}); // ignore
                                _context3.next = 25;
                                break;

                            case 24:
                                throw new _FailedToPublishError2.default(streamId, data, 'Wait for the "connected" event before calling publish, or set autoConnect to true!');

                            case 25:
                            case 'end':
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function publish(_x3, _x4) {
                return _ref3.apply(this, arguments);
            }

            return publish;
        }()
    }, {
        key: 'subscribe',
        value: function subscribe(optionsOrStreamId, callback, legacyOptions) {
            var _this3 = this;

            if (!optionsOrStreamId) {
                throw new Error('subscribe: Invalid arguments: subscription options is required!');
            } else if (!callback) {
                throw new Error('subscribe: Invalid arguments: callback is required!');
            }

            // Backwards compatibility for giving a streamId as first argument
            var options = void 0;
            if (typeof optionsOrStreamId === 'string') {
                options = {
                    stream: optionsOrStreamId
                };
            } else if ((typeof optionsOrStreamId === 'undefined' ? 'undefined' : (0, _typeof3.default)(optionsOrStreamId)) === 'object') {
                options = optionsOrStreamId;
            } else {
                throw new Error('subscribe: options must be an object! Given: ' + optionsOrStreamId);
            }

            // Backwards compatibility for giving an options object as third argument
            (0, _assign2.default)(options, legacyOptions);

            if (!options.stream) {
                throw new Error('subscribe: Invalid arguments: options.stream is not given');
            }

            // Create the Subscription object and bind handlers
            var sub = new _Subscription2.default(options.stream, options.partition || 0, options.apiKey || this.options.auth.apiKey, callback, options);
            sub.on('gap', function (from, to) {
                if (!sub.resending) {
                    _this3._requestResend(sub, {
                        resend_from: from, resend_to: to
                    });
                }
            });
            sub.on('done', function () {
                debug('done event for sub %d', sub.id);
                _this3.unsubscribe(sub);
            });

            // Add to lookups
            this._addSubscription(sub);

            // If connected, emit a subscribe request
            if (this.connection.state === _Connection2.default.State.CONNECTED) {
                this._resendAndSubscribe(sub);
            } else if (this.options.autoConnect) {
                this.connect().catch(function () {}); // ignore
            }

            return sub;
        }
    }, {
        key: 'unsubscribe',
        value: function unsubscribe(sub) {
            if (!sub || !sub.streamId) {
                throw new Error('unsubscribe: please give a Subscription object as an argument!');
            }

            // If this is the last subscription for this stream, unsubscribe the client too
            if (this.subscribedStreams[sub.streamId] !== undefined && this.subscribedStreams[sub.streamId].getSubscriptions().length === 1 && this.isConnected() && sub.getState() === _Subscription2.default.State.subscribed) {
                sub.setState(_Subscription2.default.State.unsubscribing);
                this._requestUnsubscribe(sub.streamId);
            } else if (sub.getState() !== _Subscription2.default.State.unsubscribing && sub.getState() !== _Subscription2.default.State.unsubscribed) {
                // Else the sub can be cleaned off immediately
                this._removeSubscription(sub);
                sub.setState(_Subscription2.default.State.unsubscribed);
                this._checkAutoDisconnect();
            }
        }
    }, {
        key: 'unsubscribeAll',
        value: function unsubscribeAll(streamId) {
            var _this4 = this;

            if (!streamId) {
                throw new Error('unsubscribeAll: a stream id is required!');
            } else if (typeof streamId !== 'string') {
                throw new Error('unsubscribe: stream id must be a string!');
            }

            var stream = this.subscribedStreams[streamId];
            if (stream) {
                stream.getSubscriptions().forEach(function (sub) {
                    _this4.unsubscribe(sub);
                });
            }
        }
    }, {
        key: 'isConnected',
        value: function isConnected() {
            return this.connection.state === _Connection2.default.State.CONNECTED;
        }
    }, {
        key: 'reconnect',
        value: function reconnect() {
            return this.connect();
        }
    }, {
        key: 'connect',
        value: function connect() {
            if (this.isConnected()) {
                return _promise2.default.reject(new Error('Already connected!'));
            } else if (this.connection.state === _Connection2.default.State.CONNECTING) {
                return _promise2.default.reject(new Error('Already connecting!'));
            }

            debug('Connecting to %s', this.options.url);
            return this.connection.connect();
        }
    }, {
        key: 'pause',
        value: function pause() {
            return this.connection.disconnect();
        }
    }, {
        key: 'disconnect',
        value: function disconnect() {
            this.subscribedStreams = {};
            return this.connection.disconnect();
        }
    }, {
        key: '_checkAutoDisconnect',
        value: function _checkAutoDisconnect() {
            // Disconnect if no longer subscribed to any streams
            if (this.options.autoDisconnect && (0, _keys2.default)(this.subscribedStreams).length === 0) {
                debug('Disconnecting due to no longer being subscribed to any streams');
                this.disconnect();
            }
        }
    }, {
        key: '_resendAndSubscribe',
        value: function _resendAndSubscribe(sub) {
            var _this5 = this;

            if (sub.getState() !== _Subscription2.default.State.subscribing && !sub.resending) {
                sub.setState(_Subscription2.default.State.subscribing);
                this._requestSubscribe(sub);

                // Once subscribed, ask for a resend
                sub.once('subscribed', function () {
                    if (sub.hasResendOptions()) {
                        _this5._requestResend(sub);
                    }
                });
            }
        }
    }, {
        key: '_requestSubscribe',
        value: function _requestSubscribe(sub) {
            var _this6 = this;

            var stream = this.subscribedStreams[sub.streamId];
            var subscribedSubs = stream.getSubscriptions().filter(function (it) {
                return it.getState() === _Subscription2.default.State.subscribed;
            });

            return this.session.getSessionToken().then(function (sessionToken) {
                // If this is the first subscription for this stream, send a subscription request to the server
                if (!stream.isSubscribing() && subscribedSubs.length === 0) {
                    var request = new _streamrClientProtocol.SubscribeRequest(sub.streamId, undefined, sub.apiKey, sessionToken);
                    debug('_requestSubscribe: subscribing client: %o', request);
                    stream.setSubscribing(true);
                    _this6.connection.send(request);
                } else if (subscribedSubs.length > 0) {
                    // If there already is a subscribed subscription for this stream, this new one will just join it immediately
                    debug('_requestSubscribe: another subscription for same stream: %s, insta-subscribing', sub.streamId);

                    setTimeout(function () {
                        sub.setState(_Subscription2.default.State.subscribed);
                    });
                }
            });
        }
    }, {
        key: '_requestUnsubscribe',
        value: function _requestUnsubscribe(streamId) {
            debug('Client unsubscribing stream %o', streamId);
            this.connection.send(new _streamrClientProtocol.UnsubscribeRequest(streamId));
        }
    }, {
        key: '_requestResend',
        value: function _requestResend(sub, resendOptions) {
            var _this7 = this;

            sub.setResending(true);
            return this.session.getSessionToken().then(function (sessionToken) {
                var request = new _streamrClientProtocol.ResendRequest(sub.streamId, sub.streamPartition, sub.id, resendOptions || sub.getEffectiveResendOptions(), sub.apiKey, sessionToken);
                debug('_requestResend: %o', request);
                _this7.connection.send(request);
            });
        }
    }, {
        key: '_requestPublish',
        value: function _requestPublish(streamId, data, timestamp, apiKey, sessionToken) {
            var _this8 = this;

            var request = new _streamrClientProtocol.PublishRequest(streamId, apiKey, sessionToken, data, timestamp);
            var requestToSendPromise = this.signer ? this.signer.getSignedPublishRequest(request) : _promise2.default.resolve(request);
            return requestToSendPromise.then(function (requestToSend) {
                debug('_requestPublish: %o', requestToSend);
                return _this8.connection.send(requestToSend);
            });
        }
    }, {
        key: 'handleError',
        value: function handleError(msg) {
            debug(msg);
            this.emit('error', msg);
        }
    }]);
    return StreamrClient;
}(_eventemitter2.default);

exports.default = StreamrClient;
module.exports = exports['default'];

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/typeof");

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/toConsumableArray");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _keys = __webpack_require__(9);

var _keys2 = _interopRequireDefault(_keys);

var _stringify = __webpack_require__(11);

var _stringify2 = _interopRequireDefault(_stringify);

var _getPrototypeOf = __webpack_require__(5);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(6);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(3);

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(7);

var _inherits3 = _interopRequireDefault(_inherits2);

var _eventemitter = __webpack_require__(12);

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _debug = __webpack_require__(4);

var _debug2 = _interopRequireDefault(_debug);

var _streamrClientProtocol = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)('StreamrClient::Subscription');

var subId = 0;
function generateSubscriptionId() {
    var id = subId;
    subId += 1;
    return id.toString();
}

var Subscription = function (_EventEmitter) {
    (0, _inherits3.default)(Subscription, _EventEmitter);
    (0, _createClass3.default)(Subscription, null, [{
        key: 'State',
        get: function get() {
            return {
                unsubscribed: 'unsubscribed',
                subscribing: 'subscribing',
                subscribed: 'subscribed',
                unsubscribing: 'unsubscribing'
            };
        }
    }]);

    function Subscription(streamId, streamPartition, apiKey, callback, options) {
        (0, _classCallCheck3.default)(this, Subscription);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Subscription.__proto__ || (0, _getPrototypeOf2.default)(Subscription)).call(this));

        if (!streamId) {
            throw new Error('No stream id given!');
        }
        if (!callback) {
            throw new Error('No callback given!');
        }

        _this.id = generateSubscriptionId();
        _this.streamId = streamId;
        _this.streamPartition = streamPartition;
        _this.apiKey = apiKey;
        _this.callback = callback;
        _this.options = options || {};
        _this.queue = [];
        _this.state = Subscription.State.unsubscribed;
        _this.resending = false;
        _this.lastReceivedOffset = null;

        // Check that multiple resend options are not given
        var resendOptionCount = 0;
        if (_this.options.resend_all) {
            resendOptionCount += 1;
        }
        if (_this.options.resend_from != null) {
            resendOptionCount += 1;
        }
        if (_this.options.resend_last != null) {
            resendOptionCount += 1;
        }
        if (_this.options.resend_from_time != null) {
            resendOptionCount += 1;
        }
        if (resendOptionCount > 1) {
            throw new Error('Multiple resend options active! Please use only one: ' + (0, _stringify2.default)(options));
        }

        // Automatically convert Date objects to numbers for resend_from_time
        if (_this.options.resend_from_time != null && typeof _this.options.resend_from_time !== 'number') {
            if (typeof _this.options.resend_from_time.getTime === 'function') {
                _this.options.resend_from_time = _this.options.resend_from_time.getTime();
            } else {
                throw new Error('resend_from_time option must be a Date object or a number representing time!');
            }
        }

        /** * Message handlers ** */

        _this.on('unsubscribed', function () {
            _this.setResending(false);
        });

        _this.on('no_resend', function (response) {
            debug('Sub %s no_resend: %o', _this.id, response);
            _this.setResending(false);
            _this.checkQueue();
        });

        _this.on('resent', function (response) {
            debug('Sub %s resent: %o', _this.id, response);
            _this.setResending(false);
            _this.checkQueue();
        });

        _this.on('connected', function () {});

        _this.on('disconnected', function () {
            _this.setState(Subscription.State.unsubscribed);
            _this.setResending(false);
        });
        return _this;
    }

    /**
     * Gap check: If the msg contains the previousOffset, and we know the lastReceivedOffset,
     * and the previousOffset is larger than what has been received, we have a gap!
     */


    (0, _createClass3.default)(Subscription, [{
        key: 'checkForGap',
        value: function checkForGap(previousOffset) {
            return previousOffset != null && this.lastReceivedOffset != null && previousOffset > this.lastReceivedOffset;
        }
    }, {
        key: 'handleMessage',
        value: function handleMessage(msg) {
            var isResend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            if (msg.previousOffset == null) {
                debug('handleMessage: prevOffset is null, gap detection is impossible! message: %o', msg);
            }

            // TODO: check this.options.resend_last ?
            // If resending, queue broadcasted messages
            if (this.resending && !isResend) {
                this.queue.push(msg);
            } else if (this.checkForGap(msg.previousOffset) && !this.resending) {
                // Queue the message to be processed after resend
                this.queue.push(msg);

                var from = this.lastReceivedOffset + 1;
                var to = msg.previousOffset;
                debug('Gap detected, requesting resend for stream %s from %d to %d', this.streamId, from, to);
                this.emit('gap', from, to);
            } else if (this.lastReceivedOffset != null && msg.offset <= this.lastReceivedOffset) {
                // Prevent double-processing of messages for any reason
                debug('Sub %s already received message: %d, lastReceivedOffset: %d. Ignoring message.', this.id, msg.offset, this.lastReceivedOffset);
            } else {
                // Normal case where prevOffset == null || lastReceivedOffset == null || prevOffset === lastReceivedOffset
                this.lastReceivedOffset = msg.offset;
                this.callback(msg.getParsedContent(), msg);
                if (msg.isByeMessage()) {
                    this.emit('done');
                }
            }
        }
    }, {
        key: 'checkQueue',
        value: function checkQueue() {
            var _this2 = this;

            if (this.queue.length) {
                debug('Attempting to process %d queued messages for stream %s', this.queue.length, this.streamId);

                var originalQueue = this.queue;
                this.queue = [];

                originalQueue.forEach(function (msg) {
                    return _this2.handleMessage(msg, false);
                });
            }
        }
    }, {
        key: 'hasResendOptions',
        value: function hasResendOptions() {
            return this.options.resend_all === true || this.options.resend_from >= 0 || this.options.resend_from_time >= 0 || this.options.resend_last > 0;
        }

        /**
         * Resend needs can change if messages have already been received.
         * This function always returns the effective resend options:
         *
         * If messages have been received:
         * - resend_all becomes resend_from
         * - resend_from becomes resend_from the latest received message
         * - resend_from_time becomes resend_from the latest received message
         * - resend_last stays the same
         */

    }, {
        key: 'getEffectiveResendOptions',
        value: function getEffectiveResendOptions() {
            var _this3 = this;

            if (this.hasReceivedMessages() && this.hasResendOptions() && (this.options.resend_all || this.options.resend_from || this.options.resend_from_time)) {
                return {
                    resend_from: this.lastReceivedOffset + 1
                };
            }

            // Pick resend options from the options
            var result = {};
            (0, _keys2.default)(this.options).forEach(function (key) {
                if (key.startsWith('resend_')) {
                    result[key] = _this3.options[key];
                }
            });
            return result;
        }
    }, {
        key: 'hasReceivedMessages',
        value: function hasReceivedMessages() {
            return this.lastReceivedOffset != null;
        }
    }, {
        key: 'getState',
        value: function getState() {
            return this.state;
        }
    }, {
        key: 'setState',
        value: function setState(state) {
            debug('Subscription: Stream ' + this.streamId + ' state changed ' + this.state + ' => ' + state);
            this.state = state;
            this.emit(state);
        }
    }, {
        key: 'isResending',
        value: function isResending() {
            return this.resending;
        }
    }, {
        key: 'setResending',
        value: function setResending(resending) {
            debug('Subscription: Stream ' + this.streamId + ' resending: ' + resending);
            this.resending = resending;
        }
    }, {
        key: 'handleError',
        value: function handleError(err) {
            /**
             * If parsing the (expected) message failed, we should still mark it as received. Otherwise the
             * gap detection will think a message was lost, and re-request the failing message.
             */
            if (err instanceof _streamrClientProtocol.Errors.InvalidJsonError && !this.checkForGap(err.streamMessage.previousOffset)) {
                this.lastReceivedOffset = err.streamMessage.offset;
            }
            this.emit('error', err);
        }
    }]);
    return Subscription;
}(_eventemitter2.default);

exports.default = Subscription;
module.exports = exports['default'];

/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = require("node-fetch");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promise = __webpack_require__(14);

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = __webpack_require__(5);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(3);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(6);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(7);

var _inherits3 = _interopRequireDefault(_inherits2);

var _eventemitter = __webpack_require__(12);

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _debug = __webpack_require__(4);

var _debug2 = _interopRequireDefault(_debug);

var _ws = __webpack_require__(32);

var _ws2 = _interopRequireDefault(_ws);

var _streamrClientProtocol = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)('StreamrClient::Connection');

var Connection = function (_EventEmitter) {
    (0, _inherits3.default)(Connection, _EventEmitter);

    function Connection(options, socket) {
        (0, _classCallCheck3.default)(this, Connection);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Connection.__proto__ || (0, _getPrototypeOf2.default)(Connection)).call(this));

        if (!options.url) {
            throw new Error('URL is not defined!');
        }
        _this.options = options;
        _this.state = Connection.State.DISCONNECTED;
        _this.socket = socket;

        if (options.autoConnect) {
            _this.connect();
        }
        return _this;
    }

    (0, _createClass3.default)(Connection, [{
        key: 'updateState',
        value: function updateState(state) {
            this.state = state;
            this.emit(state);
        }
    }, {
        key: 'connect',
        value: function connect() {
            var _this2 = this;

            if (this.state === Connection.State.CONNECTING) {
                return _promise2.default.reject(new Error('Already connecting!'));
            } else if (this.state === Connection.State.CONNECTED) {
                return _promise2.default.reject(new Error('Already connected!'));
            }
            this.socket = this.socket || new _ws2.default(this.options.url);
            this.socket.binaryType = 'arraybuffer';
            this.socket.events = new _eventemitter2.default();
            this.socket.onopen = function () {
                return _this2.socket.events.emit('open');
            };
            this.socket.onclose = function () {
                return _this2.socket.events.emit('close');
            };

            this.updateState(Connection.State.CONNECTING);

            this.socket.events.on('open', function () {
                debug('Connected to ', _this2.options.url);
                _this2.updateState(Connection.State.CONNECTED);
            });

            this.socket.events.on('close', function () {
                if (_this2.state !== Connection.State.DISCONNECTING) {
                    debug('Connection lost. Attempting to reconnect');
                    setTimeout(function () {
                        _this2.connect();
                    }, 2000);
                }

                _this2.updateState(Connection.State.DISCONNECTED);
            });

            this.socket.onmessage = function (messageEvent) {
                try {
                    var websocketResponse = _streamrClientProtocol.WebsocketResponse.deserialize(messageEvent.data);
                    _this2.emit(websocketResponse.constructor.getMessageName(), websocketResponse);
                } catch (err) {
                    _this2.emit('error', err);
                }
            };

            return new _promise2.default(function (resolve) {
                _this2.socket.events.once('open', function () {
                    resolve();
                });
            });
        }
    }, {
        key: 'disconnect',
        value: function disconnect() {
            var _this3 = this;

            if (this.state === Connection.State.DISCONNECTING) {
                return _promise2.default.reject(new Error('Already disconnecting!'));
            } else if (this.state === Connection.State.DISCONNECTED) {
                return _promise2.default.reject(new Error('Already disconnected!'));
            } else if (this.socket === undefined) {
                return _promise2.default.reject(new Error('Something is wrong: socket is undefined!'));
            }

            return new _promise2.default(function (resolve) {
                _this3.updateState(Connection.State.DISCONNECTING);
                _this3.socket.events.once('close', resolve);
                _this3.socket.close();
            });
        }
    }, {
        key: 'send',
        value: function send(websocketRequest) {
            try {
                this.socket.send(websocketRequest.serialize());
            } catch (err) {
                this.emit('error', err);
            }
        }
    }]);
    return Connection;
}(_eventemitter2.default);

Connection.State = {
    DISCONNECTED: 'disconnected',
    CONNECTING: 'connecting',
    CONNECTED: 'connected',
    DISCONNECTING: 'disconnecting'
};

module.exports = Connection;

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = require("ws");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(2);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(3);

var _createClass3 = _interopRequireDefault(_createClass2);

var _web = __webpack_require__(17);

var _web2 = _interopRequireDefault(_web);

var _web3FakeProvider = __webpack_require__(18);

var _web3FakeProvider2 = _interopRequireDefault(_web3FakeProvider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var web3 = new _web2.default(new _web3FakeProvider2.default());

var Session = function () {
    function Session(client, options) {
        var _this = this;

        (0, _classCallCheck3.default)(this, Session);

        this._client = client;
        this.options = options || {};
        this.state = Session.State.LOGGED_OUT;

        if (typeof this.options.privateKey !== 'undefined') {
            var account = web3.eth.accounts.privateKeyToAccount(this.options.privateKey);
            this.loginFunction = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                return _context.abrupt('return', _this._client.loginWithChallengeResponse(function (d) {
                                    return account.sign(d).signature;
                                }, account.address));

                            case 1:
                            case 'end':
                                return _context.stop();
                        }
                    }
                }, _callee, _this);
            }));
        } else if (typeof this.options.provider !== 'undefined') {
            var w3 = new _web2.default(this.options.provider);
            this.loginFunction = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                var accounts, address;
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                _context2.next = 2;
                                return w3.eth.getAccounts();

                            case 2:
                                accounts = _context2.sent;
                                address = accounts[0];

                                if (address) {
                                    _context2.next = 6;
                                    break;
                                }

                                throw new Error('Cannot access account from provider');

                            case 6:
                                return _context2.abrupt('return', _this._client.loginWithChallengeResponse(function (d) {
                                    return w3.eth.personal.sign(d, address);
                                }, address));

                            case 7:
                            case 'end':
                                return _context2.stop();
                        }
                    }
                }, _callee2, _this);
            }));
        } else if (typeof this.options.apiKey !== 'undefined') {
            this.loginFunction = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                return _context3.abrupt('return', _this._client.loginWithApiKey(_this.options.apiKey));

                            case 1:
                            case 'end':
                                return _context3.stop();
                        }
                    }
                }, _callee3, _this);
            }));
        } else if (typeof this.options.username !== 'undefined' && typeof this.options.password !== 'undefined') {
            this.loginFunction = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
                return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                return _context4.abrupt('return', _this._client.loginWithUsernamePassword(_this.options.username, _this.options.password));

                            case 1:
                            case 'end':
                                return _context4.stop();
                        }
                    }
                }, _callee4, _this);
            }));
        } else {
            if (!this.options.sessionToken) {
                this.options.unauthenticated = true;
            }
            this.loginFunction = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
                return _regenerator2.default.wrap(function _callee5$(_context5) {
                    while (1) {
                        switch (_context5.prev = _context5.next) {
                            case 0:
                                throw new Error('Need either "privateKey", "provider", "apiKey" or "username"+"password" to login.');

                            case 1:
                            case 'end':
                                return _context5.stop();
                        }
                    }
                }, _callee5, _this);
            }));
        }
    }

    (0, _createClass3.default)(Session, [{
        key: 'getSessionToken',
        value: function () {
            var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
                var _this2 = this;

                var requireNewToken = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                return _regenerator2.default.wrap(function _callee6$(_context6) {
                    while (1) {
                        switch (_context6.prev = _context6.next) {
                            case 0:
                                if (!(this.options.sessionToken && !requireNewToken)) {
                                    _context6.next = 2;
                                    break;
                                }

                                return _context6.abrupt('return', this.options.sessionToken);

                            case 2:
                                if (!this.options.unauthenticated) {
                                    _context6.next = 4;
                                    break;
                                }

                                return _context6.abrupt('return', undefined);

                            case 4:
                                if (this.state !== Session.State.LOGGING_IN) {
                                    this.state = Session.State.LOGGING_IN;
                                    this.sessionTokenPromise = this.loginFunction().then(function (tokenObj) {
                                        _this2.options.sessionToken = tokenObj.token;
                                        _this2.state = Session.State.LOGGED_IN;
                                        return tokenObj.token;
                                    }).catch(function (err) {
                                        _this2.state = Session.State.LOGGED_OUT;
                                        throw err;
                                    });
                                }
                                return _context6.abrupt('return', this.sessionTokenPromise);

                            case 6:
                            case 'end':
                                return _context6.stop();
                        }
                    }
                }, _callee6, this);
            }));

            function getSessionToken() {
                return _ref6.apply(this, arguments);
            }

            return getSessionToken;
        }()
    }]);
    return Session;
}();

exports.default = Session;


Session.State = {
    LOGGED_OUT: 'logged out',
    LOGGING_IN: 'logging in',
    LOGGED_IN: 'logged in'
};
module.exports = exports['default'];

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _create = __webpack_require__(21);

var _create2 = _interopRequireDefault(_create);

var _setPrototypeOf = __webpack_require__(22);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _from = __webpack_require__(23);

var _from2 = _interopRequireDefault(_from);

var _construct = __webpack_require__(24);

var _construct2 = _interopRequireDefault(_construct);

var _getPrototypeOf = __webpack_require__(5);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(6);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(7);

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extendableBuiltin(cls) {
    function ExtendableBuiltin() {
        var instance = (0, _construct2.default)(cls, (0, _from2.default)(arguments));
        (0, _setPrototypeOf2.default)(instance, (0, _getPrototypeOf2.default)(this));
        return instance;
    }

    ExtendableBuiltin.prototype = (0, _create2.default)(cls.prototype, {
        constructor: {
            value: cls,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });

    if (_setPrototypeOf2.default) {
        (0, _setPrototypeOf2.default)(ExtendableBuiltin, cls);
    } else {
        ExtendableBuiltin.__proto__ = cls;
    }

    return ExtendableBuiltin;
}

module.exports = function (_extendableBuiltin2) {
    (0, _inherits3.default)(FailedToPublishError, _extendableBuiltin2);

    function FailedToPublishError(streamId, msg, reason) {
        (0, _classCallCheck3.default)(this, FailedToPublishError);

        var _this = (0, _possibleConstructorReturn3.default)(this, (FailedToPublishError.__proto__ || (0, _getPrototypeOf2.default)(FailedToPublishError)).call(this, "Failed to publish to stream " + streamId + " due to: " + reason + ". Message was: " + msg));

        _this.streamId = streamId;
        _this.msg = msg;
        _this.reason = reason;
        return _this;
    }

    return FailedToPublishError;
}(_extendableBuiltin(Error));

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _create = __webpack_require__(21);

var _create2 = _interopRequireDefault(_create);

var _setPrototypeOf = __webpack_require__(22);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _from = __webpack_require__(23);

var _from2 = _interopRequireDefault(_from);

var _construct = __webpack_require__(24);

var _construct2 = _interopRequireDefault(_construct);

var _getPrototypeOf = __webpack_require__(5);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(6);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(7);

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extendableBuiltin(cls) {
    function ExtendableBuiltin() {
        var instance = (0, _construct2.default)(cls, (0, _from2.default)(arguments));
        (0, _setPrototypeOf2.default)(instance, (0, _getPrototypeOf2.default)(this));
        return instance;
    }

    ExtendableBuiltin.prototype = (0, _create2.default)(cls.prototype, {
        constructor: {
            value: cls,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });

    if (_setPrototypeOf2.default) {
        (0, _setPrototypeOf2.default)(ExtendableBuiltin, cls);
    } else {
        ExtendableBuiltin.__proto__ = cls;
    }

    return ExtendableBuiltin;
}

module.exports = function (_extendableBuiltin2) {
    (0, _inherits3.default)(InvalidSignatureError, _extendableBuiltin2);

    function InvalidSignatureError(streamMessage) {
        (0, _classCallCheck3.default)(this, InvalidSignatureError);

        var _this = (0, _possibleConstructorReturn3.default)(this, (InvalidSignatureError.__proto__ || (0, _getPrototypeOf2.default)(InvalidSignatureError)).call(this, "Invalid message signature: " + streamMessage.serialize()));

        _this.streamMessage = streamMessage;
        return _this;
    }

    return InvalidSignatureError;
}(_extendableBuiltin(Error));

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _keys = __webpack_require__(9);

var _keys2 = _interopRequireDefault(_keys);

var _values = __webpack_require__(37);

var _values2 = _interopRequireDefault(_values);

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _set = __webpack_require__(20);

var _set2 = _interopRequireDefault(_set);

var _asyncToGenerator2 = __webpack_require__(2);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(3);

var _createClass3 = _interopRequireDefault(_createClass2);

var _Signer = __webpack_require__(19);

var _Signer2 = _interopRequireDefault(_Signer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SubscribedStream = function () {
    function SubscribedStream(client, streamId) {
        (0, _classCallCheck3.default)(this, SubscribedStream);

        this._client = client;
        this.streamId = streamId;
        this.subscriptions = {};
        if (client.options.verifySignatures === 'always') {
            this.verifySignatures = true;
        } else if (client.options.verifySignatures === 'never') {
            this.verifySignatures = false;
        } else if (client.options.verifySignatures === 'auto') {
            this.verifySignatures = undefined; // Will retrieve it from the stream's metadata in getVerifySignatures() method
        } else {
            throw new Error('Unrecognized verifySignatures parameter value: ' + client.options.verifySignatures);
        }
    }

    (0, _createClass3.default)(SubscribedStream, [{
        key: 'getPublishers',
        value: function getPublishers() {
            if (!this.publishersPromise) {
                this.publishersPromise = this._client.getStreamPublishers(this.streamId);
            }
            return this.publishersPromise;
        }
    }, {
        key: 'verifyStreamMessage',
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(msg) {
                var publishers;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                if (!(msg.signatureType && msg.signatureType !== 0)) {
                                    _context.next = 5;
                                    break;
                                }

                                _context.next = 3;
                                return this.getPublishers();

                            case 3:
                                publishers = _context.sent;
                                return _context.abrupt('return', _Signer2.default.verifyStreamMessage(msg, new _set2.default(publishers)));

                            case 5:
                                _context.next = 7;
                                return this.getVerifySignatures();

                            case 7:
                                return _context.abrupt('return', !_context.sent);

                            case 8:
                            case 'end':
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function verifyStreamMessage(_x) {
                return _ref.apply(this, arguments);
            }

            return verifyStreamMessage;
        }()
    }, {
        key: 'getStream',
        value: function () {
            var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                if (!this.streamPromise) {
                                    this.streamPromise = this._client.getStream(this.streamId);
                                }
                                return _context2.abrupt('return', this.streamPromise);

                            case 2:
                            case 'end':
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function getStream() {
                return _ref2.apply(this, arguments);
            }

            return getStream;
        }()
    }, {
        key: 'getVerifySignatures',
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
                var stream;
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                if (!(this.verifySignatures === undefined)) {
                                    _context3.next = 5;
                                    break;
                                }

                                _context3.next = 3;
                                return this.getStream();

                            case 3:
                                stream = _context3.sent;

                                this.verifySignatures = stream.requireSignedData;

                            case 5:
                                return _context3.abrupt('return', this.verifySignatures);

                            case 6:
                            case 'end':
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function getVerifySignatures() {
                return _ref3.apply(this, arguments);
            }

            return getVerifySignatures;
        }()
    }, {
        key: 'getSubscription',
        value: function getSubscription(subId) {
            return this.subscriptions[subId];
        }
    }, {
        key: 'getSubscriptions',
        value: function getSubscriptions() {
            return (0, _values2.default)(this.subscriptions) || [];
        }
    }, {
        key: 'isSubscribing',
        value: function isSubscribing() {
            return this.subscribing;
        }
    }, {
        key: 'setSubscribing',
        value: function setSubscribing(value) {
            this.subscribing = value;
        }
    }, {
        key: 'emptySubscriptionsSet',
        value: function emptySubscriptionsSet() {
            return (0, _keys2.default)(this.subscriptions).length === 0;
        }
    }, {
        key: 'addSubscription',
        value: function addSubscription(sub) {
            this.subscriptions[sub.id] = sub;
        }
    }, {
        key: 'removeSubscription',
        value: function removeSubscription(sub) {
            delete this.subscriptions[sub.id];
        }
    }]);
    return SubscribedStream;
}();

exports.default = SubscribedStream;
module.exports = exports['default'];

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/values");

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends2 = __webpack_require__(16);

var _extends3 = _interopRequireDefault(_extends2);

var _StreamEndpoints = __webpack_require__(39);

var StreamEndpoints = _interopRequireWildcard(_StreamEndpoints);

var _LoginEndpoints = __webpack_require__(43);

var LoginEndpoints = _interopRequireWildcard(_LoginEndpoints);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = (0, _extends3.default)({}, StreamEndpoints, LoginEndpoints);

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getStreamPublishers = exports.getOrCreateStream = exports.createStream = exports.getStreamByName = exports.listStreams = exports.getStream = undefined;

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _stringify = __webpack_require__(11);

var _stringify2 = _interopRequireDefault(_stringify);

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(2);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

// These function are mixed in to StreamrClient.prototype.
// In the below functions, 'this' is intended to be the StreamrClient
var getStream = exports.getStream = function () {
    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(streamId) {
        var url, json;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        url = this.options.restUrl + '/streams/' + streamId;
                        _context.next = 3;
                        return (0, _utils.authFetch)(url, this.session);

                    case 3:
                        json = _context.sent;
                        return _context.abrupt('return', json ? new _Stream2.default(this, json) : undefined);

                    case 5:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    }));

    return function getStream(_x) {
        return _ref.apply(this, arguments);
    };
}();

var listStreams = exports.listStreams = function () {
    var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
        var _this = this;

        var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var url, json;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        url = this.options.restUrl + '/streams?' + _querystring2.default.stringify(query);
                        _context2.next = 3;
                        return (0, _utils.authFetch)(url, this.session);

                    case 3:
                        json = _context2.sent;
                        return _context2.abrupt('return', json ? json.map(function (stream) {
                            return new _Stream2.default(_this, stream);
                        }) : []);

                    case 5:
                    case 'end':
                        return _context2.stop();
                }
            }
        }, _callee2, this);
    }));

    return function listStreams() {
        return _ref2.apply(this, arguments);
    };
}();

var getStreamByName = exports.getStreamByName = function () {
    var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(name) {
        var json;
        return _regenerator2.default.wrap(function _callee3$(_context3) {
            while (1) {
                switch (_context3.prev = _context3.next) {
                    case 0:
                        _context3.next = 2;
                        return this.listStreams({
                            name: name,
                            public: false
                        });

                    case 2:
                        json = _context3.sent;
                        return _context3.abrupt('return', json[0] ? new _Stream2.default(this, json[0]) : undefined);

                    case 4:
                    case 'end':
                        return _context3.stop();
                }
            }
        }, _callee3, this);
    }));

    return function getStreamByName(_x3) {
        return _ref3.apply(this, arguments);
    };
}();

var createStream = exports.createStream = function () {
    var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(props) {
        var json;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
            while (1) {
                switch (_context4.prev = _context4.next) {
                    case 0:
                        if (!(!props || !props.name)) {
                            _context4.next = 2;
                            break;
                        }

                        throw new Error('Stream properties must contain a "name" field!');

                    case 2:
                        _context4.next = 4;
                        return (0, _utils.authFetch)(this.options.restUrl + '/streams', this.session, {
                            method: 'POST',
                            body: (0, _stringify2.default)(props)
                        });

                    case 4:
                        json = _context4.sent;
                        return _context4.abrupt('return', json ? new _Stream2.default(this, json) : undefined);

                    case 6:
                    case 'end':
                        return _context4.stop();
                }
            }
        }, _callee4, this);
    }));

    return function createStream(_x4) {
        return _ref4.apply(this, arguments);
    };
}();

var getOrCreateStream = exports.getOrCreateStream = function () {
    var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(props) {
        var json;
        return _regenerator2.default.wrap(function _callee5$(_context5) {
            while (1) {
                switch (_context5.prev = _context5.next) {
                    case 0:
                        json = void 0;

                        // Try looking up the stream by id or name, whichever is defined

                        if (!props.id) {
                            _context5.next = 7;
                            break;
                        }

                        _context5.next = 4;
                        return this.getStream(props.id);

                    case 4:
                        json = _context5.sent;
                        _context5.next = 11;
                        break;

                    case 7:
                        if (!props.name) {
                            _context5.next = 11;
                            break;
                        }

                        _context5.next = 10;
                        return this.getStreamByName(props.name);

                    case 10:
                        json = _context5.sent;

                    case 11:
                        if (json) {
                            _context5.next = 16;
                            break;
                        }

                        _context5.next = 14;
                        return this.createStream(props);

                    case 14:
                        json = _context5.sent;

                        debug('Created stream: %s (%s)', props.name, json.id);

                    case 16:
                        if (json) {
                            _context5.next = 20;
                            break;
                        }

                        throw new Error('Unable to find or create stream: ' + props.name);

                    case 20:
                        return _context5.abrupt('return', new _Stream2.default(this, json));

                    case 21:
                    case 'end':
                        return _context5.stop();
                }
            }
        }, _callee5, this);
    }));

    return function getOrCreateStream(_x5) {
        return _ref5.apply(this, arguments);
    };
}();

var getStreamPublishers = exports.getStreamPublishers = function () {
    var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(streamId) {
        var url, json;
        return _regenerator2.default.wrap(function _callee6$(_context6) {
            while (1) {
                switch (_context6.prev = _context6.next) {
                    case 0:
                        url = this.options.restUrl + '/streams/' + streamId + '/publishers';
                        _context6.next = 3;
                        return (0, _utils.authFetch)(url, this.session);

                    case 3:
                        json = _context6.sent;
                        return _context6.abrupt('return', json.addresses.map(function (a) {
                            return a.toLowerCase();
                        }));

                    case 5:
                    case 'end':
                        return _context6.stop();
                }
            }
        }, _callee6, this);
    }));

    return function getStreamPublishers(_x6) {
        return _ref6.apply(this, arguments);
    };
}();

exports.publishHttp = publishHttp;

var _querystring = __webpack_require__(40);

var _querystring2 = _interopRequireDefault(_querystring);

var _http = __webpack_require__(41);

var _https = __webpack_require__(42);

var _debug = __webpack_require__(4);

var _debug2 = _interopRequireDefault(_debug);

var _Stream = __webpack_require__(15);

var _Stream2 = _interopRequireDefault(_Stream);

var _utils = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)('StreamrClient');

var agentSettings = {
    keepAlive: true,
    keepAliveMsecs: 5000
};

var agentByProtocol = {
    http: new _http.Agent(agentSettings),
    https: new _https.Agent(agentSettings)
};

function getKeepAliveAgentForUrl(url) {
    if (url.startsWith('https')) {
        return agentByProtocol.https;
    } else if (url.startsWith('http')) {
        return agentByProtocol.http;
    }

    throw new Error('Unknown protocol in URL: ' + url);
}function publishHttp(streamObjectOrId, data) {
    var requestOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var keepAlive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    var streamId = void 0;
    if (streamObjectOrId instanceof _Stream2.default) {
        streamId = streamObjectOrId.id;
    } else {
        streamId = streamObjectOrId;
    }

    // Send data to the stream
    return (0, _utils.authFetch)(this.options.restUrl + '/streams/' + streamId + '/data', this.session, (0, _assign2.default)({}, requestOptions, {
        method: 'POST',
        body: (0, _stringify2.default)(data),
        agent: keepAlive ? getKeepAliveAgentForUrl(this.options.restUrl) : undefined
    }));
}

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.loginWithUsernamePassword = exports.loginWithApiKey = exports.loginWithChallengeResponse = exports.sendChallengeResponse = exports.getChallenge = undefined;

var _regenerator = __webpack_require__(1);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = __webpack_require__(11);

var _stringify2 = _interopRequireDefault(_stringify);

var _asyncToGenerator2 = __webpack_require__(2);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var getSessionToken = function () {
    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(url, props) {
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        return _context.abrupt('return', (0, _utils.authFetch)(url, undefined, {
                            method: 'POST',
                            body: (0, _stringify2.default)(props),
                            headers: {
                                'Content-Type': 'application/json'
                            }
                        }));

                    case 1:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    }));

    return function getSessionToken(_x, _x2) {
        return _ref.apply(this, arguments);
    };
}();

var getChallenge = exports.getChallenge = function () {
    var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(address) {
        var url;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        url = this.options.restUrl + '/login/challenge/' + address;
                        return _context2.abrupt('return', (0, _utils.authFetch)(url, undefined, {
                            method: 'POST'
                        }));

                    case 2:
                    case 'end':
                        return _context2.stop();
                }
            }
        }, _callee2, this);
    }));

    return function getChallenge(_x3) {
        return _ref2.apply(this, arguments);
    };
}();

var sendChallengeResponse = exports.sendChallengeResponse = function () {
    var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(challenge, signature, address) {
        var url, props;
        return _regenerator2.default.wrap(function _callee3$(_context3) {
            while (1) {
                switch (_context3.prev = _context3.next) {
                    case 0:
                        url = this.options.restUrl + '/login/response';
                        props = {
                            challenge: challenge,
                            signature: signature,
                            address: address
                        };
                        return _context3.abrupt('return', getSessionToken(url, props));

                    case 3:
                    case 'end':
                        return _context3.stop();
                }
            }
        }, _callee3, this);
    }));

    return function sendChallengeResponse(_x4, _x5, _x6) {
        return _ref3.apply(this, arguments);
    };
}();

var loginWithChallengeResponse = exports.loginWithChallengeResponse = function () {
    var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(signingFunction, address) {
        var challenge, signature;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
            while (1) {
                switch (_context4.prev = _context4.next) {
                    case 0:
                        _context4.next = 2;
                        return this.getChallenge(address);

                    case 2:
                        challenge = _context4.sent;
                        _context4.next = 5;
                        return signingFunction(challenge.challenge);

                    case 5:
                        signature = _context4.sent;
                        return _context4.abrupt('return', this.sendChallengeResponse(challenge, signature, address));

                    case 7:
                    case 'end':
                        return _context4.stop();
                }
            }
        }, _callee4, this);
    }));

    return function loginWithChallengeResponse(_x7, _x8) {
        return _ref4.apply(this, arguments);
    };
}();

var loginWithApiKey = exports.loginWithApiKey = function () {
    var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(apiKey) {
        var url, props;
        return _regenerator2.default.wrap(function _callee5$(_context5) {
            while (1) {
                switch (_context5.prev = _context5.next) {
                    case 0:
                        url = this.options.restUrl + '/login/apikey';
                        props = {
                            apiKey: apiKey
                        };
                        return _context5.abrupt('return', getSessionToken(url, props));

                    case 3:
                    case 'end':
                        return _context5.stop();
                }
            }
        }, _callee5, this);
    }));

    return function loginWithApiKey(_x9) {
        return _ref5.apply(this, arguments);
    };
}();

var loginWithUsernamePassword = exports.loginWithUsernamePassword = function () {
    var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(username, password) {
        var url, props;
        return _regenerator2.default.wrap(function _callee6$(_context6) {
            while (1) {
                switch (_context6.prev = _context6.next) {
                    case 0:
                        url = this.options.restUrl + '/login/password';
                        props = {
                            username: username,
                            password: password
                        };
                        return _context6.abrupt('return', getSessionToken(url, props));

                    case 3:
                    case 'end':
                        return _context6.stop();
                }
            }
        }, _callee6, this);
    }));

    return function loginWithUsernamePassword(_x10, _x11) {
        return _ref6.apply(this, arguments);
    };
}();

var _utils = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ })
/******/ ]);
});
//# sourceMappingURL=streamr-client.js.map